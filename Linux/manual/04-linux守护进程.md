# Linux 守护进程

守护进程英文名叫做 `daemon`，一直在后台运行的进程，我们就称它为 `守护进程`。

> 提示：拿 Windows 来对比，加入系统服务(service)的程序功能就与 Linux 下的守护进程差不多了！

## 一、问题的由来

Web 应用写好后，下一件事就是启动，让它一直在后台运行。但是这并不容易。举例来说：

1. 下面是一个最简单的 Node 应用 server.js，只有 6 行：

   ```js
   var http = require("http");

   http
     .createServer(function(req, res) {
       res.writeHead(200, { "Content-Type": "text/plain" });
       res.end("Hello World");
     })
     .listen(5000);
   ```

2. 在命令行下启动它：

   ```sh
   $ node server.js
   ```

   看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。

   > 怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？

## 二、前台任务与后台任务

| 概念                     | 描述                                                       |
| ------------------------ | ---------------------------------------------------------- |
| 前台任务(foreground job) | 独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令 |
| 后台任务(background job) | 应用程序关闭之后依然可以继续运行相关的服务                 |

> 变成守护进程的第一步，就是把它改成"后台任务"。

1. 改成后台任务

   只要在命令的尾部加上符号`&`，启动的进程就会成为"后台任务"。

   ```sh
   $ node server.js &
   ```

   如果要让正在运行的"前台任务"变为"后台任务"，可以先按 `ctrl + z`，然后执行 `bg` 命令（让最近一个暂停的"后台任务"继续执行）。

2. "后台任务"有两个特点

   | 序号 | 后台任务的特点                                                                                                          |
   | ---- | ----------------------------------------------------------------------------------------------------------------------- |
   | 01   | 继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。 |
   | 02   | 不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。    |

   > 可以看到，`后台任务` 与 `前台任务` 的本质区别只有一个：是否继承标准输入（stdin）。所以，执行后台任务的同时，用户还可以输入其他命令。

3. 疑问：

   变为 `后台任务` 后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后， `后台任务` 是否还会继续执行？

## 三、SIGHUP 信号

`SIGHUP` 是 unix 中进程组织结构为 session 包含一个前台进程组及一个或多个后台进程组，一个进程组包含多个进程。

1. Linux 系统是这样设计 `前台任务` 退出的：

   | 序号 | `前台任务` 退出的步骤                |
   | ---- | ------------------------------------ |
   | 01   | 用户准备退出 session                 |
   | 02   | 系统向该 session 发出 SIGHUP 信号    |
   | 03   | session 将 SIGHUP 信号发给所有子进程 |
   | 04   | 子进程收到 SIGHUP 信号后，自动退出   |

   > 上面的流程解释了，为什么 `前台任务` 会随着 session 的退出而退出：因为它收到了 SIGHUP 信号。

2. 疑问：那么，`后台任务` 是否也会收到 SIGHUP 信号？

   `后台任务` 是否会收到 SIGHUP 信号，这由 Shell 的 `huponexit` 参数决定的。

   ```sh
   $ shopt | grep huponexit
   ```

   > 执行上面的命令，就会看到 huponexit 参数的值：

   | 参数值 | huponexit 参数值描述                             | 设置参数值指令     |
   | ------ | ------------------------------------------------ | ------------------ |
   | off    | session 退出时，不会把 SIGHUP 信号发给"后台任务" | shopt -u huponexit |
   | on     | session 退出时，会把 SIGHUP 信号发给"后台任务"   | shopt -s huponexit |

   > 提示：大多数 Linux 系统，这个参数默认关闭（off）。因此一般来说，"后台任务" 通常会是 `守护进程`。

## 四、disown 命令

通过"后台任务"启动"守护进程"并不保险，因为有的系统的 huponexit 参数可能是打开的（on）。

1. disown 命令启动守护进程更加保险

   更保险的方法是使用 disown 命令。它可以将指定任务从"后台任务"列表（jobs 命令的返回结果）之中移除。一个"后台任务"只要不在这个列表之中，session 就肯定不会向它发出 SIGHUP 信号。

   ```sh
   $ node server.js &
   $ disown
   ```

   > 执行上面的命令以后，server.js 进程就被移出了"后台任务"列表。你可以执行 jobs 命令验证，输出结果里面，不会有这个进程。

2. disown 的具体用法如下：

   ```sh
   # 移出最近一个正在执行的后台任务
   $ disown

   # 移出所有正在执行的后台任务
   $ disown -r

   # 移出所有后台任务
   $ disown -a

   # 不移出后台任务，但是让它们不会收到SIGHUP信号
   $ disown -h

   # 根据jobId，移出指定的后台任务
   $ disown %2
   $ disown -h %2
   ```

## 五、标准 I/O

使用 disown 命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准 I/O 有交互，它还是会挂掉。

1. 还是以上面的脚本为例，现在加入一行：

   ```js
   var http = require("http");

   http
     .createServer(function(req, res) {
       console.log("server starts..."); // 加入此行
       res.writeHead(200, { "Content-Type": "text/plain" });
       res.end("Hello World");
     })
     .listen(5000);
   ```

2. 启动上面的脚本，然后再执行 disown 命令：

   ```sh
   $ node server.js &
   $ disown
   ```

3. 接着，你退出 session，访问 5000 端口，就会发现连不上。

   这是因为"后台任务"的标准 I/O 继承自当前 session，disown 命令并没有改变这一点。一旦"后台任务"读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。

4. 为了解决上面这个问题，需要对"后台任务"的标准 I/O 进行重定向。

   ```sh
   $ node server.js > stdout.txt 2> stderr.txt < /dev/null &
   $ disown
   ```

   > 上面这样执行，`守护进程` 基本上就没有问题了。

## 六、nohup 命令

还有比 disown 更方便的命令，就是 nohup。

```sh
$ nohup node server.js &
```

nohup 命令对 server.js 进程做了三件事：

```
1. 阻止SIGHUP信号发到这个进程。
2. 关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。
3. 重定向标准输出和标准错误到文件nohup.out。
```

也就是说，nohup 命令实际上将子进程与它所在的 session 分离了。

> 注意：nohup 命令不会自动把进程变为 `后台任务` ，所以命令结尾必须加上 `&` 符号。

## 七、其它工具

处理以上命令可以实现守护进程外，还有其它工具，列表如下：

| 守护进程工具         | 描述                                             |
| -------------------- | ------------------------------------------------ |
| Screen               | 终端命令                                         |
| Tmux                 | 终端命令                                         |
| 程序专有守护进程工具 | nodejs、php、mariadb、nginx 都自带守护进程启动器 |

## 八、Systemd

Linux 系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务。
